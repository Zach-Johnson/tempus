// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: api/v1/tempus/tempus.proto

package tempusv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CategoryService_CreateCategory_FullMethodName = "/drummer.v1.CategoryService/CreateCategory"
	CategoryService_GetCategory_FullMethodName    = "/drummer.v1.CategoryService/GetCategory"
	CategoryService_ListCategories_FullMethodName = "/drummer.v1.CategoryService/ListCategories"
	CategoryService_UpdateCategory_FullMethodName = "/drummer.v1.CategoryService/UpdateCategory"
	CategoryService_DeleteCategory_FullMethodName = "/drummer.v1.CategoryService/DeleteCategory"
)

// CategoryServiceClient is the client API for CategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CategoryServiceClient interface {
	// Create a new category
	CreateCategory(ctx context.Context, in *CreateCategoryRequest, opts ...grpc.CallOption) (*Category, error)
	// Get a category by ID
	GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*Category, error)
	// List categories with optional pagination
	ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error)
	// Update a category
	UpdateCategory(ctx context.Context, in *UpdateCategoryRequest, opts ...grpc.CallOption) (*Category, error)
	// Delete a category
	DeleteCategory(ctx context.Context, in *DeleteCategoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type categoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCategoryServiceClient(cc grpc.ClientConnInterface) CategoryServiceClient {
	return &categoryServiceClient{cc}
}

func (c *categoryServiceClient) CreateCategory(ctx context.Context, in *CreateCategoryRequest, opts ...grpc.CallOption) (*Category, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Category)
	err := c.cc.Invoke(ctx, CategoryService_CreateCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*Category, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Category)
	err := c.cc.Invoke(ctx, CategoryService_GetCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCategoriesResponse)
	err := c.cc.Invoke(ctx, CategoryService_ListCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) UpdateCategory(ctx context.Context, in *UpdateCategoryRequest, opts ...grpc.CallOption) (*Category, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Category)
	err := c.cc.Invoke(ctx, CategoryService_UpdateCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) DeleteCategory(ctx context.Context, in *DeleteCategoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CategoryService_DeleteCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CategoryServiceServer is the server API for CategoryService service.
// All implementations should embed UnimplementedCategoryServiceServer
// for forward compatibility.
type CategoryServiceServer interface {
	// Create a new category
	CreateCategory(context.Context, *CreateCategoryRequest) (*Category, error)
	// Get a category by ID
	GetCategory(context.Context, *GetCategoryRequest) (*Category, error)
	// List categories with optional pagination
	ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error)
	// Update a category
	UpdateCategory(context.Context, *UpdateCategoryRequest) (*Category, error)
	// Delete a category
	DeleteCategory(context.Context, *DeleteCategoryRequest) (*emptypb.Empty, error)
}

// UnimplementedCategoryServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCategoryServiceServer struct{}

func (UnimplementedCategoryServiceServer) CreateCategory(context.Context, *CreateCategoryRequest) (*Category, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCategory not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategory(context.Context, *GetCategoryRequest) (*Category, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategory not implemented")
}
func (UnimplementedCategoryServiceServer) ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCategories not implemented")
}
func (UnimplementedCategoryServiceServer) UpdateCategory(context.Context, *UpdateCategoryRequest) (*Category, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCategory not implemented")
}
func (UnimplementedCategoryServiceServer) DeleteCategory(context.Context, *DeleteCategoryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCategory not implemented")
}
func (UnimplementedCategoryServiceServer) testEmbeddedByValue() {}

// UnsafeCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServiceServer will
// result in compilation errors.
type UnsafeCategoryServiceServer interface {
	mustEmbedUnimplementedCategoryServiceServer()
}

func RegisterCategoryServiceServer(s grpc.ServiceRegistrar, srv CategoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedCategoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CategoryService_ServiceDesc, srv)
}

func _CategoryService_CreateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).CreateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_CreateCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).CreateCategory(ctx, req.(*CreateCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategory(ctx, req.(*GetCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_ListCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).ListCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_ListCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).ListCategories(ctx, req.(*ListCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_UpdateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).UpdateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_UpdateCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).UpdateCategory(ctx, req.(*UpdateCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_DeleteCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_DeleteCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, req.(*DeleteCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CategoryService_ServiceDesc is the grpc.ServiceDesc for CategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "drummer.v1.CategoryService",
	HandlerType: (*CategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCategory",
			Handler:    _CategoryService_CreateCategory_Handler,
		},
		{
			MethodName: "GetCategory",
			Handler:    _CategoryService_GetCategory_Handler,
		},
		{
			MethodName: "ListCategories",
			Handler:    _CategoryService_ListCategories_Handler,
		},
		{
			MethodName: "UpdateCategory",
			Handler:    _CategoryService_UpdateCategory_Handler,
		},
		{
			MethodName: "DeleteCategory",
			Handler:    _CategoryService_DeleteCategory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/tempus/tempus.proto",
}

const (
	TagService_CreateTag_FullMethodName = "/drummer.v1.TagService/CreateTag"
	TagService_GetTag_FullMethodName    = "/drummer.v1.TagService/GetTag"
	TagService_ListTags_FullMethodName  = "/drummer.v1.TagService/ListTags"
	TagService_UpdateTag_FullMethodName = "/drummer.v1.TagService/UpdateTag"
	TagService_DeleteTag_FullMethodName = "/drummer.v1.TagService/DeleteTag"
)

// TagServiceClient is the client API for TagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagServiceClient interface {
	// Create a new tag
	CreateTag(ctx context.Context, in *CreateTagRequest, opts ...grpc.CallOption) (*Tag, error)
	// Get a tag by ID
	GetTag(ctx context.Context, in *GetTagRequest, opts ...grpc.CallOption) (*Tag, error)
	// List tags with optional pagination and filtering
	ListTags(ctx context.Context, in *ListTagsRequest, opts ...grpc.CallOption) (*ListTagsResponse, error)
	// Update a tag
	UpdateTag(ctx context.Context, in *UpdateTagRequest, opts ...grpc.CallOption) (*Tag, error)
	// Delete a tag
	DeleteTag(ctx context.Context, in *DeleteTagRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type tagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagServiceClient(cc grpc.ClientConnInterface) TagServiceClient {
	return &tagServiceClient{cc}
}

func (c *tagServiceClient) CreateTag(ctx context.Context, in *CreateTagRequest, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagService_CreateTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetTag(ctx context.Context, in *GetTagRequest, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagService_GetTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) ListTags(ctx context.Context, in *ListTagsRequest, opts ...grpc.CallOption) (*ListTagsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTagsResponse)
	err := c.cc.Invoke(ctx, TagService_ListTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) UpdateTag(ctx context.Context, in *UpdateTagRequest, opts ...grpc.CallOption) (*Tag, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tag)
	err := c.cc.Invoke(ctx, TagService_UpdateTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) DeleteTag(ctx context.Context, in *DeleteTagRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TagService_DeleteTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServiceServer is the server API for TagService service.
// All implementations should embed UnimplementedTagServiceServer
// for forward compatibility.
type TagServiceServer interface {
	// Create a new tag
	CreateTag(context.Context, *CreateTagRequest) (*Tag, error)
	// Get a tag by ID
	GetTag(context.Context, *GetTagRequest) (*Tag, error)
	// List tags with optional pagination and filtering
	ListTags(context.Context, *ListTagsRequest) (*ListTagsResponse, error)
	// Update a tag
	UpdateTag(context.Context, *UpdateTagRequest) (*Tag, error)
	// Delete a tag
	DeleteTag(context.Context, *DeleteTagRequest) (*emptypb.Empty, error)
}

// UnimplementedTagServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTagServiceServer struct{}

func (UnimplementedTagServiceServer) CreateTag(context.Context, *CreateTagRequest) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTag not implemented")
}
func (UnimplementedTagServiceServer) GetTag(context.Context, *GetTagRequest) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTag not implemented")
}
func (UnimplementedTagServiceServer) ListTags(context.Context, *ListTagsRequest) (*ListTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTags not implemented")
}
func (UnimplementedTagServiceServer) UpdateTag(context.Context, *UpdateTagRequest) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTag not implemented")
}
func (UnimplementedTagServiceServer) DeleteTag(context.Context, *DeleteTagRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTag not implemented")
}
func (UnimplementedTagServiceServer) testEmbeddedByValue() {}

// UnsafeTagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServiceServer will
// result in compilation errors.
type UnsafeTagServiceServer interface {
	mustEmbedUnimplementedTagServiceServer()
}

func RegisterTagServiceServer(s grpc.ServiceRegistrar, srv TagServiceServer) {
	// If the following call pancis, it indicates UnimplementedTagServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TagService_ServiceDesc, srv)
}

func _TagService_CreateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).CreateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_CreateTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).CreateTag(ctx, req.(*CreateTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetTag(ctx, req.(*GetTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_ListTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).ListTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_ListTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).ListTags(ctx, req.(*ListTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_UpdateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).UpdateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_UpdateTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).UpdateTag(ctx, req.(*UpdateTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_DeleteTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).DeleteTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_DeleteTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).DeleteTag(ctx, req.(*DeleteTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TagService_ServiceDesc is the grpc.ServiceDesc for TagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "drummer.v1.TagService",
	HandlerType: (*TagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTag",
			Handler:    _TagService_CreateTag_Handler,
		},
		{
			MethodName: "GetTag",
			Handler:    _TagService_GetTag_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _TagService_ListTags_Handler,
		},
		{
			MethodName: "UpdateTag",
			Handler:    _TagService_UpdateTag_Handler,
		},
		{
			MethodName: "DeleteTag",
			Handler:    _TagService_DeleteTag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/tempus/tempus.proto",
}

const (
	ExerciseService_CreateExercise_FullMethodName      = "/drummer.v1.ExerciseService/CreateExercise"
	ExerciseService_GetExercise_FullMethodName         = "/drummer.v1.ExerciseService/GetExercise"
	ExerciseService_ListExercises_FullMethodName       = "/drummer.v1.ExerciseService/ListExercises"
	ExerciseService_UpdateExercise_FullMethodName      = "/drummer.v1.ExerciseService/UpdateExercise"
	ExerciseService_DeleteExercise_FullMethodName      = "/drummer.v1.ExerciseService/DeleteExercise"
	ExerciseService_AddExerciseImage_FullMethodName    = "/drummer.v1.ExerciseService/AddExerciseImage"
	ExerciseService_GetExerciseImage_FullMethodName    = "/drummer.v1.ExerciseService/GetExerciseImage"
	ExerciseService_DeleteExerciseImage_FullMethodName = "/drummer.v1.ExerciseService/DeleteExerciseImage"
	ExerciseService_AddExerciseLink_FullMethodName     = "/drummer.v1.ExerciseService/AddExerciseLink"
	ExerciseService_DeleteExerciseLink_FullMethodName  = "/drummer.v1.ExerciseService/DeleteExerciseLink"
	ExerciseService_GetExerciseStats_FullMethodName    = "/drummer.v1.ExerciseService/GetExerciseStats"
)

// ExerciseServiceClient is the client API for ExerciseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExerciseServiceClient interface {
	// Create a new exercise
	CreateExercise(ctx context.Context, in *CreateExerciseRequest, opts ...grpc.CallOption) (*Exercise, error)
	// Get an exercise by ID
	GetExercise(ctx context.Context, in *GetExerciseRequest, opts ...grpc.CallOption) (*Exercise, error)
	// List exercises with optional pagination and filtering
	ListExercises(ctx context.Context, in *ListExercisesRequest, opts ...grpc.CallOption) (*ListExercisesResponse, error)
	// Update an exercise
	UpdateExercise(ctx context.Context, in *UpdateExerciseRequest, opts ...grpc.CallOption) (*Exercise, error)
	// Delete an exercise
	DeleteExercise(ctx context.Context, in *DeleteExerciseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Add an image to an exercise
	AddExerciseImage(ctx context.Context, in *AddExerciseImageRequest, opts ...grpc.CallOption) (*ExerciseImage, error)
	GetExerciseImage(ctx context.Context, in *GetExerciseImageRequest, opts ...grpc.CallOption) (*ExerciseImage, error)
	// Delete an image from an exercise
	DeleteExerciseImage(ctx context.Context, in *DeleteExerciseImageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Add a link to an exercise
	AddExerciseLink(ctx context.Context, in *AddExerciseLinkRequest, opts ...grpc.CallOption) (*ExerciseLink, error)
	// Delete a link from an exercise
	DeleteExerciseLink(ctx context.Context, in *DeleteExerciseLinkRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Get statistics for an exercise
	GetExerciseStats(ctx context.Context, in *GetExerciseStatsRequest, opts ...grpc.CallOption) (*ExerciseStats, error)
}

type exerciseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExerciseServiceClient(cc grpc.ClientConnInterface) ExerciseServiceClient {
	return &exerciseServiceClient{cc}
}

func (c *exerciseServiceClient) CreateExercise(ctx context.Context, in *CreateExerciseRequest, opts ...grpc.CallOption) (*Exercise, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Exercise)
	err := c.cc.Invoke(ctx, ExerciseService_CreateExercise_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) GetExercise(ctx context.Context, in *GetExerciseRequest, opts ...grpc.CallOption) (*Exercise, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Exercise)
	err := c.cc.Invoke(ctx, ExerciseService_GetExercise_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) ListExercises(ctx context.Context, in *ListExercisesRequest, opts ...grpc.CallOption) (*ListExercisesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExercisesResponse)
	err := c.cc.Invoke(ctx, ExerciseService_ListExercises_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) UpdateExercise(ctx context.Context, in *UpdateExerciseRequest, opts ...grpc.CallOption) (*Exercise, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Exercise)
	err := c.cc.Invoke(ctx, ExerciseService_UpdateExercise_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) DeleteExercise(ctx context.Context, in *DeleteExerciseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ExerciseService_DeleteExercise_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) AddExerciseImage(ctx context.Context, in *AddExerciseImageRequest, opts ...grpc.CallOption) (*ExerciseImage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseImage)
	err := c.cc.Invoke(ctx, ExerciseService_AddExerciseImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) GetExerciseImage(ctx context.Context, in *GetExerciseImageRequest, opts ...grpc.CallOption) (*ExerciseImage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseImage)
	err := c.cc.Invoke(ctx, ExerciseService_GetExerciseImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) DeleteExerciseImage(ctx context.Context, in *DeleteExerciseImageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ExerciseService_DeleteExerciseImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) AddExerciseLink(ctx context.Context, in *AddExerciseLinkRequest, opts ...grpc.CallOption) (*ExerciseLink, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseLink)
	err := c.cc.Invoke(ctx, ExerciseService_AddExerciseLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) DeleteExerciseLink(ctx context.Context, in *DeleteExerciseLinkRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ExerciseService_DeleteExerciseLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseServiceClient) GetExerciseStats(ctx context.Context, in *GetExerciseStatsRequest, opts ...grpc.CallOption) (*ExerciseStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseStats)
	err := c.cc.Invoke(ctx, ExerciseService_GetExerciseStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExerciseServiceServer is the server API for ExerciseService service.
// All implementations should embed UnimplementedExerciseServiceServer
// for forward compatibility.
type ExerciseServiceServer interface {
	// Create a new exercise
	CreateExercise(context.Context, *CreateExerciseRequest) (*Exercise, error)
	// Get an exercise by ID
	GetExercise(context.Context, *GetExerciseRequest) (*Exercise, error)
	// List exercises with optional pagination and filtering
	ListExercises(context.Context, *ListExercisesRequest) (*ListExercisesResponse, error)
	// Update an exercise
	UpdateExercise(context.Context, *UpdateExerciseRequest) (*Exercise, error)
	// Delete an exercise
	DeleteExercise(context.Context, *DeleteExerciseRequest) (*emptypb.Empty, error)
	// Add an image to an exercise
	AddExerciseImage(context.Context, *AddExerciseImageRequest) (*ExerciseImage, error)
	GetExerciseImage(context.Context, *GetExerciseImageRequest) (*ExerciseImage, error)
	// Delete an image from an exercise
	DeleteExerciseImage(context.Context, *DeleteExerciseImageRequest) (*emptypb.Empty, error)
	// Add a link to an exercise
	AddExerciseLink(context.Context, *AddExerciseLinkRequest) (*ExerciseLink, error)
	// Delete a link from an exercise
	DeleteExerciseLink(context.Context, *DeleteExerciseLinkRequest) (*emptypb.Empty, error)
	// Get statistics for an exercise
	GetExerciseStats(context.Context, *GetExerciseStatsRequest) (*ExerciseStats, error)
}

// UnimplementedExerciseServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExerciseServiceServer struct{}

func (UnimplementedExerciseServiceServer) CreateExercise(context.Context, *CreateExerciseRequest) (*Exercise, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExercise not implemented")
}
func (UnimplementedExerciseServiceServer) GetExercise(context.Context, *GetExerciseRequest) (*Exercise, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExercise not implemented")
}
func (UnimplementedExerciseServiceServer) ListExercises(context.Context, *ListExercisesRequest) (*ListExercisesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExercises not implemented")
}
func (UnimplementedExerciseServiceServer) UpdateExercise(context.Context, *UpdateExerciseRequest) (*Exercise, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExercise not implemented")
}
func (UnimplementedExerciseServiceServer) DeleteExercise(context.Context, *DeleteExerciseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExercise not implemented")
}
func (UnimplementedExerciseServiceServer) AddExerciseImage(context.Context, *AddExerciseImageRequest) (*ExerciseImage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddExerciseImage not implemented")
}
func (UnimplementedExerciseServiceServer) GetExerciseImage(context.Context, *GetExerciseImageRequest) (*ExerciseImage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExerciseImage not implemented")
}
func (UnimplementedExerciseServiceServer) DeleteExerciseImage(context.Context, *DeleteExerciseImageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExerciseImage not implemented")
}
func (UnimplementedExerciseServiceServer) AddExerciseLink(context.Context, *AddExerciseLinkRequest) (*ExerciseLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddExerciseLink not implemented")
}
func (UnimplementedExerciseServiceServer) DeleteExerciseLink(context.Context, *DeleteExerciseLinkRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExerciseLink not implemented")
}
func (UnimplementedExerciseServiceServer) GetExerciseStats(context.Context, *GetExerciseStatsRequest) (*ExerciseStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExerciseStats not implemented")
}
func (UnimplementedExerciseServiceServer) testEmbeddedByValue() {}

// UnsafeExerciseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExerciseServiceServer will
// result in compilation errors.
type UnsafeExerciseServiceServer interface {
	mustEmbedUnimplementedExerciseServiceServer()
}

func RegisterExerciseServiceServer(s grpc.ServiceRegistrar, srv ExerciseServiceServer) {
	// If the following call pancis, it indicates UnimplementedExerciseServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExerciseService_ServiceDesc, srv)
}

func _ExerciseService_CreateExercise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExerciseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).CreateExercise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_CreateExercise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).CreateExercise(ctx, req.(*CreateExerciseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_GetExercise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExerciseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).GetExercise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_GetExercise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).GetExercise(ctx, req.(*GetExerciseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_ListExercises_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExercisesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).ListExercises(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_ListExercises_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).ListExercises(ctx, req.(*ListExercisesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_UpdateExercise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExerciseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).UpdateExercise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_UpdateExercise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).UpdateExercise(ctx, req.(*UpdateExerciseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_DeleteExercise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExerciseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).DeleteExercise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_DeleteExercise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).DeleteExercise(ctx, req.(*DeleteExerciseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_AddExerciseImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddExerciseImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).AddExerciseImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_AddExerciseImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).AddExerciseImage(ctx, req.(*AddExerciseImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_GetExerciseImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExerciseImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).GetExerciseImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_GetExerciseImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).GetExerciseImage(ctx, req.(*GetExerciseImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_DeleteExerciseImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExerciseImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).DeleteExerciseImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_DeleteExerciseImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).DeleteExerciseImage(ctx, req.(*DeleteExerciseImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_AddExerciseLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddExerciseLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).AddExerciseLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_AddExerciseLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).AddExerciseLink(ctx, req.(*AddExerciseLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_DeleteExerciseLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExerciseLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).DeleteExerciseLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_DeleteExerciseLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).DeleteExerciseLink(ctx, req.(*DeleteExerciseLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseService_GetExerciseStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExerciseStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseServiceServer).GetExerciseStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseService_GetExerciseStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseServiceServer).GetExerciseStats(ctx, req.(*GetExerciseStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExerciseService_ServiceDesc is the grpc.ServiceDesc for ExerciseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExerciseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "drummer.v1.ExerciseService",
	HandlerType: (*ExerciseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateExercise",
			Handler:    _ExerciseService_CreateExercise_Handler,
		},
		{
			MethodName: "GetExercise",
			Handler:    _ExerciseService_GetExercise_Handler,
		},
		{
			MethodName: "ListExercises",
			Handler:    _ExerciseService_ListExercises_Handler,
		},
		{
			MethodName: "UpdateExercise",
			Handler:    _ExerciseService_UpdateExercise_Handler,
		},
		{
			MethodName: "DeleteExercise",
			Handler:    _ExerciseService_DeleteExercise_Handler,
		},
		{
			MethodName: "AddExerciseImage",
			Handler:    _ExerciseService_AddExerciseImage_Handler,
		},
		{
			MethodName: "GetExerciseImage",
			Handler:    _ExerciseService_GetExerciseImage_Handler,
		},
		{
			MethodName: "DeleteExerciseImage",
			Handler:    _ExerciseService_DeleteExerciseImage_Handler,
		},
		{
			MethodName: "AddExerciseLink",
			Handler:    _ExerciseService_AddExerciseLink_Handler,
		},
		{
			MethodName: "DeleteExerciseLink",
			Handler:    _ExerciseService_DeleteExerciseLink_Handler,
		},
		{
			MethodName: "GetExerciseStats",
			Handler:    _ExerciseService_GetExerciseStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/tempus/tempus.proto",
}

const (
	PracticeSessionService_CreatePracticeSession_FullMethodName = "/drummer.v1.PracticeSessionService/CreatePracticeSession"
	PracticeSessionService_GetPracticeSession_FullMethodName    = "/drummer.v1.PracticeSessionService/GetPracticeSession"
	PracticeSessionService_ListPracticeSessions_FullMethodName  = "/drummer.v1.PracticeSessionService/ListPracticeSessions"
	PracticeSessionService_UpdatePracticeSession_FullMethodName = "/drummer.v1.PracticeSessionService/UpdatePracticeSession"
	PracticeSessionService_DeletePracticeSession_FullMethodName = "/drummer.v1.PracticeSessionService/DeletePracticeSession"
	PracticeSessionService_GetPracticeStats_FullMethodName      = "/drummer.v1.PracticeSessionService/GetPracticeStats"
)

// PracticeSessionServiceClient is the client API for PracticeSessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PracticeSessionServiceClient interface {
	// Create a new practice session
	CreatePracticeSession(ctx context.Context, in *CreatePracticeSessionRequest, opts ...grpc.CallOption) (*PracticeSession, error)
	// Get a practice session by ID
	GetPracticeSession(ctx context.Context, in *GetPracticeSessionRequest, opts ...grpc.CallOption) (*PracticeSession, error)
	// List practice sessions with optional pagination and filtering
	ListPracticeSessions(ctx context.Context, in *ListPracticeSessionsRequest, opts ...grpc.CallOption) (*ListPracticeSessionsResponse, error)
	// Update a practice session
	UpdatePracticeSession(ctx context.Context, in *UpdatePracticeSessionRequest, opts ...grpc.CallOption) (*PracticeSession, error)
	// Delete a practice session
	DeletePracticeSession(ctx context.Context, in *DeletePracticeSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Get practice statistics
	GetPracticeStats(ctx context.Context, in *GetPracticeStatsRequest, opts ...grpc.CallOption) (*PracticeStats, error)
}

type practiceSessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPracticeSessionServiceClient(cc grpc.ClientConnInterface) PracticeSessionServiceClient {
	return &practiceSessionServiceClient{cc}
}

func (c *practiceSessionServiceClient) CreatePracticeSession(ctx context.Context, in *CreatePracticeSessionRequest, opts ...grpc.CallOption) (*PracticeSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PracticeSession)
	err := c.cc.Invoke(ctx, PracticeSessionService_CreatePracticeSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *practiceSessionServiceClient) GetPracticeSession(ctx context.Context, in *GetPracticeSessionRequest, opts ...grpc.CallOption) (*PracticeSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PracticeSession)
	err := c.cc.Invoke(ctx, PracticeSessionService_GetPracticeSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *practiceSessionServiceClient) ListPracticeSessions(ctx context.Context, in *ListPracticeSessionsRequest, opts ...grpc.CallOption) (*ListPracticeSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPracticeSessionsResponse)
	err := c.cc.Invoke(ctx, PracticeSessionService_ListPracticeSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *practiceSessionServiceClient) UpdatePracticeSession(ctx context.Context, in *UpdatePracticeSessionRequest, opts ...grpc.CallOption) (*PracticeSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PracticeSession)
	err := c.cc.Invoke(ctx, PracticeSessionService_UpdatePracticeSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *practiceSessionServiceClient) DeletePracticeSession(ctx context.Context, in *DeletePracticeSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PracticeSessionService_DeletePracticeSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *practiceSessionServiceClient) GetPracticeStats(ctx context.Context, in *GetPracticeStatsRequest, opts ...grpc.CallOption) (*PracticeStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PracticeStats)
	err := c.cc.Invoke(ctx, PracticeSessionService_GetPracticeStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PracticeSessionServiceServer is the server API for PracticeSessionService service.
// All implementations should embed UnimplementedPracticeSessionServiceServer
// for forward compatibility.
type PracticeSessionServiceServer interface {
	// Create a new practice session
	CreatePracticeSession(context.Context, *CreatePracticeSessionRequest) (*PracticeSession, error)
	// Get a practice session by ID
	GetPracticeSession(context.Context, *GetPracticeSessionRequest) (*PracticeSession, error)
	// List practice sessions with optional pagination and filtering
	ListPracticeSessions(context.Context, *ListPracticeSessionsRequest) (*ListPracticeSessionsResponse, error)
	// Update a practice session
	UpdatePracticeSession(context.Context, *UpdatePracticeSessionRequest) (*PracticeSession, error)
	// Delete a practice session
	DeletePracticeSession(context.Context, *DeletePracticeSessionRequest) (*emptypb.Empty, error)
	// Get practice statistics
	GetPracticeStats(context.Context, *GetPracticeStatsRequest) (*PracticeStats, error)
}

// UnimplementedPracticeSessionServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPracticeSessionServiceServer struct{}

func (UnimplementedPracticeSessionServiceServer) CreatePracticeSession(context.Context, *CreatePracticeSessionRequest) (*PracticeSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePracticeSession not implemented")
}
func (UnimplementedPracticeSessionServiceServer) GetPracticeSession(context.Context, *GetPracticeSessionRequest) (*PracticeSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPracticeSession not implemented")
}
func (UnimplementedPracticeSessionServiceServer) ListPracticeSessions(context.Context, *ListPracticeSessionsRequest) (*ListPracticeSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPracticeSessions not implemented")
}
func (UnimplementedPracticeSessionServiceServer) UpdatePracticeSession(context.Context, *UpdatePracticeSessionRequest) (*PracticeSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePracticeSession not implemented")
}
func (UnimplementedPracticeSessionServiceServer) DeletePracticeSession(context.Context, *DeletePracticeSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePracticeSession not implemented")
}
func (UnimplementedPracticeSessionServiceServer) GetPracticeStats(context.Context, *GetPracticeStatsRequest) (*PracticeStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPracticeStats not implemented")
}
func (UnimplementedPracticeSessionServiceServer) testEmbeddedByValue() {}

// UnsafePracticeSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PracticeSessionServiceServer will
// result in compilation errors.
type UnsafePracticeSessionServiceServer interface {
	mustEmbedUnimplementedPracticeSessionServiceServer()
}

func RegisterPracticeSessionServiceServer(s grpc.ServiceRegistrar, srv PracticeSessionServiceServer) {
	// If the following call pancis, it indicates UnimplementedPracticeSessionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PracticeSessionService_ServiceDesc, srv)
}

func _PracticeSessionService_CreatePracticeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePracticeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeSessionServiceServer).CreatePracticeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PracticeSessionService_CreatePracticeSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeSessionServiceServer).CreatePracticeSession(ctx, req.(*CreatePracticeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PracticeSessionService_GetPracticeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPracticeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeSessionServiceServer).GetPracticeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PracticeSessionService_GetPracticeSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeSessionServiceServer).GetPracticeSession(ctx, req.(*GetPracticeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PracticeSessionService_ListPracticeSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPracticeSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeSessionServiceServer).ListPracticeSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PracticeSessionService_ListPracticeSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeSessionServiceServer).ListPracticeSessions(ctx, req.(*ListPracticeSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PracticeSessionService_UpdatePracticeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePracticeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeSessionServiceServer).UpdatePracticeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PracticeSessionService_UpdatePracticeSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeSessionServiceServer).UpdatePracticeSession(ctx, req.(*UpdatePracticeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PracticeSessionService_DeletePracticeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePracticeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeSessionServiceServer).DeletePracticeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PracticeSessionService_DeletePracticeSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeSessionServiceServer).DeletePracticeSession(ctx, req.(*DeletePracticeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PracticeSessionService_GetPracticeStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPracticeStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeSessionServiceServer).GetPracticeStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PracticeSessionService_GetPracticeStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeSessionServiceServer).GetPracticeStats(ctx, req.(*GetPracticeStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PracticeSessionService_ServiceDesc is the grpc.ServiceDesc for PracticeSessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PracticeSessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "drummer.v1.PracticeSessionService",
	HandlerType: (*PracticeSessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePracticeSession",
			Handler:    _PracticeSessionService_CreatePracticeSession_Handler,
		},
		{
			MethodName: "GetPracticeSession",
			Handler:    _PracticeSessionService_GetPracticeSession_Handler,
		},
		{
			MethodName: "ListPracticeSessions",
			Handler:    _PracticeSessionService_ListPracticeSessions_Handler,
		},
		{
			MethodName: "UpdatePracticeSession",
			Handler:    _PracticeSessionService_UpdatePracticeSession_Handler,
		},
		{
			MethodName: "DeletePracticeSession",
			Handler:    _PracticeSessionService_DeletePracticeSession_Handler,
		},
		{
			MethodName: "GetPracticeStats",
			Handler:    _PracticeSessionService_GetPracticeStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/tempus/tempus.proto",
}

const (
	ExerciseHistoryService_CreateExerciseHistory_FullMethodName = "/drummer.v1.ExerciseHistoryService/CreateExerciseHistory"
	ExerciseHistoryService_GetExerciseHistory_FullMethodName    = "/drummer.v1.ExerciseHistoryService/GetExerciseHistory"
	ExerciseHistoryService_ListExerciseHistory_FullMethodName   = "/drummer.v1.ExerciseHistoryService/ListExerciseHistory"
	ExerciseHistoryService_UpdateExerciseHistory_FullMethodName = "/drummer.v1.ExerciseHistoryService/UpdateExerciseHistory"
	ExerciseHistoryService_DeleteExerciseHistory_FullMethodName = "/drummer.v1.ExerciseHistoryService/DeleteExerciseHistory"
)

// ExerciseHistoryServiceClient is the client API for ExerciseHistoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExerciseHistoryServiceClient interface {
	// Create a new exercise history entry
	CreateExerciseHistory(ctx context.Context, in *CreateExerciseHistoryRequest, opts ...grpc.CallOption) (*ExerciseHistory, error)
	// Get an exercise history entry by ID
	GetExerciseHistory(ctx context.Context, in *GetExerciseHistoryRequest, opts ...grpc.CallOption) (*ExerciseHistory, error)
	// List exercise history entries with optional pagination and filtering
	ListExerciseHistory(ctx context.Context, in *ListExerciseHistoryRequest, opts ...grpc.CallOption) (*ListExerciseHistoryResponse, error)
	// Update an exercise history entry
	UpdateExerciseHistory(ctx context.Context, in *UpdateExerciseHistoryRequest, opts ...grpc.CallOption) (*ExerciseHistory, error)
	// Delete an exercise history entry
	DeleteExerciseHistory(ctx context.Context, in *DeleteExerciseHistoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type exerciseHistoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExerciseHistoryServiceClient(cc grpc.ClientConnInterface) ExerciseHistoryServiceClient {
	return &exerciseHistoryServiceClient{cc}
}

func (c *exerciseHistoryServiceClient) CreateExerciseHistory(ctx context.Context, in *CreateExerciseHistoryRequest, opts ...grpc.CallOption) (*ExerciseHistory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseHistory)
	err := c.cc.Invoke(ctx, ExerciseHistoryService_CreateExerciseHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseHistoryServiceClient) GetExerciseHistory(ctx context.Context, in *GetExerciseHistoryRequest, opts ...grpc.CallOption) (*ExerciseHistory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseHistory)
	err := c.cc.Invoke(ctx, ExerciseHistoryService_GetExerciseHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseHistoryServiceClient) ListExerciseHistory(ctx context.Context, in *ListExerciseHistoryRequest, opts ...grpc.CallOption) (*ListExerciseHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExerciseHistoryResponse)
	err := c.cc.Invoke(ctx, ExerciseHistoryService_ListExerciseHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseHistoryServiceClient) UpdateExerciseHistory(ctx context.Context, in *UpdateExerciseHistoryRequest, opts ...grpc.CallOption) (*ExerciseHistory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExerciseHistory)
	err := c.cc.Invoke(ctx, ExerciseHistoryService_UpdateExerciseHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exerciseHistoryServiceClient) DeleteExerciseHistory(ctx context.Context, in *DeleteExerciseHistoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ExerciseHistoryService_DeleteExerciseHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExerciseHistoryServiceServer is the server API for ExerciseHistoryService service.
// All implementations should embed UnimplementedExerciseHistoryServiceServer
// for forward compatibility.
type ExerciseHistoryServiceServer interface {
	// Create a new exercise history entry
	CreateExerciseHistory(context.Context, *CreateExerciseHistoryRequest) (*ExerciseHistory, error)
	// Get an exercise history entry by ID
	GetExerciseHistory(context.Context, *GetExerciseHistoryRequest) (*ExerciseHistory, error)
	// List exercise history entries with optional pagination and filtering
	ListExerciseHistory(context.Context, *ListExerciseHistoryRequest) (*ListExerciseHistoryResponse, error)
	// Update an exercise history entry
	UpdateExerciseHistory(context.Context, *UpdateExerciseHistoryRequest) (*ExerciseHistory, error)
	// Delete an exercise history entry
	DeleteExerciseHistory(context.Context, *DeleteExerciseHistoryRequest) (*emptypb.Empty, error)
}

// UnimplementedExerciseHistoryServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExerciseHistoryServiceServer struct{}

func (UnimplementedExerciseHistoryServiceServer) CreateExerciseHistory(context.Context, *CreateExerciseHistoryRequest) (*ExerciseHistory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExerciseHistory not implemented")
}
func (UnimplementedExerciseHistoryServiceServer) GetExerciseHistory(context.Context, *GetExerciseHistoryRequest) (*ExerciseHistory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExerciseHistory not implemented")
}
func (UnimplementedExerciseHistoryServiceServer) ListExerciseHistory(context.Context, *ListExerciseHistoryRequest) (*ListExerciseHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExerciseHistory not implemented")
}
func (UnimplementedExerciseHistoryServiceServer) UpdateExerciseHistory(context.Context, *UpdateExerciseHistoryRequest) (*ExerciseHistory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExerciseHistory not implemented")
}
func (UnimplementedExerciseHistoryServiceServer) DeleteExerciseHistory(context.Context, *DeleteExerciseHistoryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExerciseHistory not implemented")
}
func (UnimplementedExerciseHistoryServiceServer) testEmbeddedByValue() {}

// UnsafeExerciseHistoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExerciseHistoryServiceServer will
// result in compilation errors.
type UnsafeExerciseHistoryServiceServer interface {
	mustEmbedUnimplementedExerciseHistoryServiceServer()
}

func RegisterExerciseHistoryServiceServer(s grpc.ServiceRegistrar, srv ExerciseHistoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedExerciseHistoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExerciseHistoryService_ServiceDesc, srv)
}

func _ExerciseHistoryService_CreateExerciseHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExerciseHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseHistoryServiceServer).CreateExerciseHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseHistoryService_CreateExerciseHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseHistoryServiceServer).CreateExerciseHistory(ctx, req.(*CreateExerciseHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseHistoryService_GetExerciseHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExerciseHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseHistoryServiceServer).GetExerciseHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseHistoryService_GetExerciseHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseHistoryServiceServer).GetExerciseHistory(ctx, req.(*GetExerciseHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseHistoryService_ListExerciseHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExerciseHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseHistoryServiceServer).ListExerciseHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseHistoryService_ListExerciseHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseHistoryServiceServer).ListExerciseHistory(ctx, req.(*ListExerciseHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseHistoryService_UpdateExerciseHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExerciseHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseHistoryServiceServer).UpdateExerciseHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseHistoryService_UpdateExerciseHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseHistoryServiceServer).UpdateExerciseHistory(ctx, req.(*UpdateExerciseHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExerciseHistoryService_DeleteExerciseHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExerciseHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExerciseHistoryServiceServer).DeleteExerciseHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExerciseHistoryService_DeleteExerciseHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExerciseHistoryServiceServer).DeleteExerciseHistory(ctx, req.(*DeleteExerciseHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExerciseHistoryService_ServiceDesc is the grpc.ServiceDesc for ExerciseHistoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExerciseHistoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "drummer.v1.ExerciseHistoryService",
	HandlerType: (*ExerciseHistoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateExerciseHistory",
			Handler:    _ExerciseHistoryService_CreateExerciseHistory_Handler,
		},
		{
			MethodName: "GetExerciseHistory",
			Handler:    _ExerciseHistoryService_GetExerciseHistory_Handler,
		},
		{
			MethodName: "ListExerciseHistory",
			Handler:    _ExerciseHistoryService_ListExerciseHistory_Handler,
		},
		{
			MethodName: "UpdateExerciseHistory",
			Handler:    _ExerciseHistoryService_UpdateExerciseHistory_Handler,
		},
		{
			MethodName: "DeleteExerciseHistory",
			Handler:    _ExerciseHistoryService_DeleteExerciseHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/tempus/tempus.proto",
}
