{"version":3,"file":"tags-ab17ae30.js","sources":["../../src/stores/tags.js"],"sourcesContent":["import { tagsAPI } from \"@/services/api.js\";\nimport { defineStore } from \"pinia\";\nimport { computed, ref } from \"vue\";\n\nexport const useTagsStore = defineStore(\"tags\", () => {\n    // State\n    const tags = ref([]);\n    const loading = ref(false);\n    const error = ref(null);\n    const currentTag = ref(null);\n    const currentTagLoading = ref(false);\n\n    // Getters\n    const tagsSorted = computed(\n        () => {\n            return [...tags.value].sort((a, b) => a.name.localeCompare(b.name));\n        },\n    );\n\n    const tagById = computed(() => {\n        return (id) => tags.value.find((tag) => tag.id === id);\n    });\n\n    const tagsByCategory = computed(\n        () => {\n            return (categoryId) =>\n                tags.value.filter(\n                    (tag) =>\n                        tag.categoryIds &&\n                        tag.categoryIds.includes(categoryId),\n                );\n        },\n    );\n\n    // Actions\n    async function fetchTags(params = {}) {\n        loading.value = true;\n        error.value = null;\n\n        try {\n            const response = await tagsAPI.getAll(params);\n            tags.value = response.data.tags || [];\n        } catch (err) {\n            error.value = err.message || \"Failed to fetch tags\";\n            console.error(\"Error fetching tags:\", err);\n        } finally {\n            loading.value = false;\n        }\n    }\n\n    async function fetchTag(id) {\n        currentTagLoading.value = true;\n        error.value = null;\n\n        try {\n            const response = await tagsAPI.get(id);\n            currentTag.value = response.data;\n\n            // Also update the tag in the tags array if it exists\n            const index = tags.value.findIndex((t) => t.id === id);\n            if (index !== -1) {\n                tags.value[index] = response.data;\n            } else {\n                tags.value.push(response.data);\n            }\n        } catch (err) {\n            error.value = err.message || `Failed to fetch tag with ID ${id}`;\n            console.error(`Error fetching tag ${id}:`, err);\n        } finally {\n            currentTagLoading.value = false;\n        }\n    }\n\n    async function createTag(tagData) {\n        loading.value = true;\n        error.value = null;\n\n        try {\n            const response = await tagsAPI.create(tagData);\n            const newTag = response.data;\n            tags.value.push(newTag);\n            return newTag;\n        } catch (err) {\n            error.value = err.message || \"Failed to create tag\";\n            console.error(\"Error creating tag:\", err);\n            throw err;\n        } finally {\n            loading.value = false;\n        }\n    }\n\n    async function updateTag(id, tagData, updateMask) {\n        loading.value = true;\n        error.value = null;\n\n        try {\n            // Convert paths array to comma-separated string if it's in object\n            // format\n            let formattedUpdateMask = updateMask;\n            if (\n                updateMask && typeof updateMask === \"object\" &&\n                updateMask.paths\n            ) {\n                formattedUpdateMask = updateMask.paths.join(\",\");\n            }\n\n            const response = await tagsAPI.update(\n                id,\n                tagData,\n                formattedUpdateMask,\n            );\n            const updatedTag = response.data;\n\n            // Update in the tags array\n            const index = tags.value.findIndex((t) => t.id === id);\n            if (index !== -1) {\n                tags.value[index] = updatedTag;\n            }\n\n            // Update currentTag if it's the one being edited\n            if (currentTag.value && currentTag.value.id === id) {\n                currentTag.value = updatedTag;\n            }\n\n            return updatedTag;\n        } catch (err) {\n            error.value = err.message || `Failed to update tag with ID ${id}`;\n            console.error(`Error updating tag ${id}:`, err);\n            throw err;\n        } finally {\n            loading.value = false;\n        }\n    }\n\n    async function deleteTag(id) {\n        loading.value = true;\n        error.value = null;\n\n        try {\n            await tagsAPI.delete(id);\n\n            // Remove from the tags array\n            tags.value = tags.value.filter((t) => t.id !== id);\n\n            // Clear currentTag if it's the one being deleted\n            if (currentTag.value && currentTag.value.id === id) {\n                currentTag.value = null;\n            }\n        } catch (err) {\n            error.value = err.message || `Failed to delete tag with ID ${id}`;\n            console.error(`Error deleting tag ${id}:`, err);\n            throw err;\n        } finally {\n            loading.value = false;\n        }\n    }\n\n    return {\n        // State\n        tags,\n        loading,\n        error,\n        currentTag,\n        currentTagLoading,\n\n        // Getters\n        tagsSorted,\n        tagById,\n        tagsByCategory,\n\n        // Actions\n        fetchTags,\n        fetchTag,\n        createTag,\n        updateTag,\n        deleteTag,\n    };\n});\n"],"names":["useTagsStore","defineStore","tags","ref","loading","error","currentTag","currentTagLoading","tagsSorted","computed","b","tagById","id","tag","tagsByCategory","categoryId","fetchTags","params","response","tagsAPI","err","fetchTag","index","t","createTag","tagData","newTag","updateTag","updateMask","formattedUpdateMask","updatedTag","deleteTag"],"mappings":"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"}